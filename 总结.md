## 第1节 搭建开发、运行、自动化测试环境

### Spring框架的特点或能力

- 轻量级（Lightweight）——相对于EJB
- 非侵入性（No intrusive） ——不一定要实现Spring的接口，编程时可以当这个框架不存在
-  容器（Container） ——管理java对象的容器（管理对象的生命周期、对象之间的依赖关系）
-  **依赖注入(Dependency Injection)** ——Spring帮忙创建对象和建立对象之间的依赖关系
-  **面向切面编程(Aspect Oriented Programming)** ——在横切关注面上增加功能，最为面向对象的补充
-  持久层（JDBC封装、事务管理、ORM工具整合） 
-  Web框架（MVC、其它WEB框架整合） 
-  其他企业服务的封装

### Spring的模块组成

![image-20200709141127850](总结.assets/image-20200709141127850.png)

### 基于spring的典型web分层架构示例

![image-20200709141745616](总结.assets/image-20200709141745616.png)

servlet承担两个责任

- 将请求转发到控制器
- 将控制器传过来的model和view组装成html

### 代码讲解

#### 主要目录结构

![image-20200709143040924](总结.assets/image-20200709143040924.png)

#### 配置 [^1]

以下内容可以对照

[^2]: 应用的java配置方式



- web.xml

![image-20200709143508396](总结.assets/image-20200709143508396.png)

- viewspace-servlet.xml

![image-20200709144002403](总结.assets/image-20200709144002403.png)

- applicationContext.xml

![image-20200709144600059](总结.assets/image-20200709144600059.png)

jdbcTemplate通过xml配置初始化，dao层中使用autowired注解将其注入，jdbc模板大大简化了jdbc操作

![image-20200709152054614](总结.assets/image-20200709152054614.png)

通过AOP技术，将事务管理器横切进service层

![image-20200709144816252](总结.assets/image-20200709144816252.png)

#### 从输入URL到看到结果

- 以jsp为例

输入根路径 -> servlet 返回index.jsp渲染的结果 

前端跳转到某路径 -> servlet将路径映射到对应的controller（通过RequestMapping注解） -> controller 调用service层业务逻辑，将数据储存在request.session中，并且返回视图名 -> servlet将对应视图和数据组装好返回给用户 -> 用户看到渲染后的页面

#### 构建与部署 

- 通常在开发时可以用**jetty**插件简化构建过程

1. 打包

```bash
mvn clean package #清空、重新编译打包(war)
```

2. 将war包扔到tomcat/webapps目录下，运行tomcat

#### 单元测试

##### junit 略

##### mockito 

- mock的两种方式
  - ![image-20200709153203264](总结.assets/image-20200709153203264.png)
  - ![image-20200709153244803](总结.assets/image-20200709153244803.png)
- mockito具体代码参见section1 > test

##### 构建测试环境的几种方式

- MockMvc配合mockito等构建上下文

```java
@Test
    public void loginFail() throws Exception {
        UserService userService = mock(UserService.class);
        when(userService.hasMatchUser("test", "123456")).thenReturn(false);

        LoginController controller = new LoginController(userService);
        MockMvc mockMvc = standaloneSetup(controller).build();
        mockMvc.perform(post("/admin/loginCheck.html")
                .param("userName", "test")
                .param("password", "123456"))
                .andExpect(view().name("login"))
                .andExpect(model().attributeExists("error"));

        verify(userService).hasMatchUser("test", "123456");
    }
```

- `@ContextConfiguration(locations = {"classpath:META-INF/spring/soundsystem.xml"})` resource下的资源打包后在classpath的根路径位置

  `@ContextConfiguration(classes = {CDPlayerConfig.class})`

  在Test类上加上`ContextConfiguration`注解构建上下文



## 第2节 依赖注入（Dependency Injection）

### 三种不同层次的容器

层次由低到高——

- Docker容器
  - 类似虚拟机

- web容器
  - 如tomcat\jetty等，用来运行web应用的地方
- Spring容器
  - spring框架中用来管理java对象生命周期、管理对象之间依赖关系的容器

### Spring配置

#### 两种组件扫描

![image-20200709171528398](总结.assets/image-20200709171528398.png)

- 在需要被Spring管理的类上面标记`@Component`

##### java扫描

- @Configuration表示这是一个配置文件
- @ComponentScan不带参数表示在当前包下扫描，也可以带参数

```java
@Configuration /*java配置类*/
@ComponentScan /*在当前包（可以指定包名）下寻找加了component注解的类并实例化它们*/
//@ComponentScan(basePackageClasses = {Mark.class})  /*类型安全、Marker Interface*/ 
//简写为 @ComponentScan(basePackageClasses = Mark.class)

//@ComponentScan(basePackages = {"com.abc"}) /*类型不安全（字符串容易敲错）*/
//简写为 @ComponentScan("com.abc")
public class CDPlayerConfig {
}
```

- Marker  Interface如图所示，该接口仅用来标记这个包，无其他含义

![image-20200709172503641](总结.assets/image-20200709172503641.png)

##### xml扫描

```xml
<context:component-scan base-package="soundsystem" />
```

##### 构建Spring容器

```java
ApplicationContext ctx = new AnnotationConfigApplicationContext(CDPlayerConfig.class); //对应java扫描
```

```java
ApplicationContext ctx = new ClassPathXmlApplicationContext("META-INF/spring/soundsystem.xml"); //对应xml扫描
```



#### 三种配置方案

![image-20200709162012696](总结.assets/image-20200709162012696.png)



##### 自动化配置

- 在需要被管理的类名上面加上@Component注解

![image-20200709171534047](总结.assets/image-20200709171534047.png)

​			Autowired也可以直接写在属性上

##### JavaConfig

```java
@Configuration
public class CDPlayerConfig {

    @Bean
//    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) // 每次都会创建实例
    public CompactDisc compactDisc() {
        return new SgtPeppers();
    }

    @Bean
    public CDPlayer cdPlayer(CompactDisc compactDisc) { /*依赖注入*/
        return new CDPlayer(compactDisc);
    }

    @Bean(name = {"cd2","CD2"})
    public CDPlayer cdPlayer2() { /*用函数来获取disc对象*/
        return new CDPlayer(compactDisc());
    }

}
```

##### XML配置

![image-20200712143337057](总结.assets/image-20200712143337057.png)

- CNamespaceReferenceTest-context

```xml
<beans ...>

  <bean id="compactDisc" class="soundsystem.SgtPeppers" />
        
  <bean id="cdPlayer" class="soundsystem.CDPlayer"
        c:cd-ref="compactDisc" />  <!-- c命名空间,用名为compactDisk的实例来注入名为cd的参数(不推荐) -->
</beans>
```

- CNamespaceValueTest-context

```xml
<beans ...>

  <bean id="compactDisc" class="soundsystem.BlankDisc"
        c:_0="Sgt. Pepper's Lonely Hearts Club Band" 
        c:_1="The Beatles" />
        
  <bean id="cdPlayer" class="soundsystem.CDPlayer"
        c:_0-ref="compactDisc" /> <!--只有一个参数就可以省略_0-->

</beans>
```

- ConstructorArgCollectionTest-context

```xml
<beans ...>
    
  <bean id="compactDisc" class="soundsystem.collections.BlankDisc">
    <constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />
    <constructor-arg value="The Beatles" />
    <constructor-arg>
      <list>
        <value>Sgt. Pepper's Lonely Hearts Club Band</value>
        <value>With a Little Help from My Friends</value>
        <value>Lucy in the Sky with Diamonds</value>
        <value>Getting Better</value>
        <value>Fixing a Hole</value>
        <value>She's Leaving Home</value>
        <value>Being for the Benefit of Mr. Kite!</value>
        <value>Within You Without You</value>
        <value>When I'm Sixty-Four</value>
        <value>Lovely Rita</value>
        <value>Good Morning Good Morning</value>
        <value>Sgt. Pepper's Lonely Hearts Club Band (Reprise)</value>
        <value>A Day in the Life</value>
      </list>
    </constructor-arg>
  </bean>
        
  <bean id="cdPlayer" class="soundsystem.CDPlayer">
    <constructor-arg ref="compactDisc" />
  </bean>

</beans>

```

- ConstructorArgReferenceTest-context

```xml
<beans ...>

  <bean id="compactDisc" class="soundsystem.SgtPeppers" />
        
  <bean id="cdPlayer" class="soundsystem.CDPlayer">
    <constructor-arg ref="compactDisc" />
  </bean>

</beans>
```

- ConstructorArgValueTest-context

```xml
<beans ...>

  <bean id="compactDisc"
        class="soundsystem.BlankDisc">
    <constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />
    <constructor-arg value="The Beatles" />
  </bean>
        
  <bean id="cdPlayer"
        class="soundsystem.CDPlayer">
    <constructor-arg ref="compactDisc" />
  </bean>

</beans>
```

- PNamespaceRefTest-context

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans ...>

  <bean id="compactDisc" class="soundsystem.BlankDisc">
    <constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />
    <constructor-arg value="The Beatles" />
  </bean>
        
  <bean id="cdPlayer" class="soundsystem.properties.CDPlayer">
    <property name="compactDisc" ref="compactDisc" />
  </bean>

</beans>

```

- PNamespaceValueTest-context

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans ...>

  <bean id="compactDisc"
        class="soundsystem.properties.BlankDisc"
        p:title="Sgt. Pepper's Lonely Hearts Club Band"
        p:artist="The Beatles">
    <property name="tracks">  <!--p(property)命名空间不支持集合-->
      <list>
        <value>Sgt. Pepper's Lonely Hearts Club Band</value>
        <value>With a Little Help from My Friends</value>
        <value>Lucy in the Sky with Diamonds</value>
        <value>Getting Better</value>
        <value>Fixing a Hole</value>
        <value>She's Leaving Home</value>
        <value>Being for the Benefit of Mr. Kite!</value>
        <value>Within You Without You</value>
        <value>When I'm Sixty-Four</value>
        <value>Lovely Rita</value>
        <value>Good Morning Good Morning</value>
        <value>Sgt. Pepper's Lonely Hearts Club Band (Reprise)</value>
        <value>A Day in the Life</value>
      </list>
    </property>
  </bean>
        
  <bean id="cdPlayer"
        class="soundsystem.properties.CDPlayer"
        p:compactDisc-ref="compactDisc" />

</beans>

```

- PNamespaceWithUtilNamespaceTest-context

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans ...>

  <bean id="compactDisc"
        class="soundsystem.properties.BlankDisc"
        p:title="Sgt. Pepper's Lonely Hearts Club Band"
        p:artist="The Beatles"
        p:tracks-ref="trackList" />

  <util:list id="trackList">  
    <value>Sgt. Pepper's Lonely Hearts Club Band</value>
    <value>With a Little Help from My Friends</value>
    <value>Lucy in the Sky with Diamonds</value>
      ...
  </util:list>

  <bean id="cdPlayer"
        class="soundsystem.properties.CDPlayer"
        p:compactDisc-ref="compactDisc" />

</beans>

```

- PropertyRefTest-context

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans ...>

  <bean id="compactDisc" class="soundsystem.BlankDisc">
    <constructor-arg value="Sgt. Pepper's Lonely Hearts Club Band" />
    <constructor-arg value="The Beatles" />
  </bean>
        
  <bean id="cdPlayer" class="soundsystem.properties.CDPlayer"
        p:compactDisc-ref="compactDisc" />

</beans>

```

- PropertyValueTest-context

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans ...>

  <bean id="compactDisc"
        class="soundsystem.properties.BlankDisc">
    <property name="title" value="Sgt. Pepper's Lonely Hearts Club Band" />
    <property name="artist" value="The Beatles" />
    <property name="tracks">
      <list>
        <value>Sgt. Pepper's Lonely Hearts Club Band</value>
        <value>With a Little Help from My Friends</value>
        <value>Lucy in the Sky with Diamonds</value>
          ...
      </list>
    </property>
  </bean>
        
  <bean id="cdPlayer"
        class="soundsystem.properties.CDPlayer"
        p:compactDisc-ref="compactDisc" />

</beans>

```

##### 混合配置

![image-20200712143350740](总结.assets/image-20200712143350740.png)

##### 根配置

![image-20200712143414951](总结.assets/image-20200712143414951.png)

#### 其他

- 可以给Component指定名字,`@Component(Value = "XXX")`
- `StandardOutputStreamLog`  获取控制台输出
- `System.getProperty("line.separater") ` 获取系统换行符
- Bean实现接口 `BeanNameAware` 以后，可以在setNeanName方法里面获取到bean的名字



## 第3节 面向切面编程 （AOP）

### 软件编程方法的发展

![image-20200712144311748](总结.assets/image-20200712144311748.png)

### 横切关注点

- 横向切到业务代码里面的一段逻辑或者模块

- 如日志、安全、事务和缓存等等

![image-20200712144741396](总结.assets/image-20200712144741396.png)



### AOP术语

![image-20200712205824633](总结.assets/image-20200712205824633.png)

![image-20200712210433085](总结.assets/image-20200712210433085.png)

- 下述定义存疑【下述定义是百度到的定义，和老师讲的恰好相反，我觉得应该是老师讲错了。。】

>  1.连接点（Join point）：连接点是在应用执行过程中能够插入切面（Aspect）的一个点。这些点可以是调用方法时、甚至修改一个字段时。
>
> 2.切点（Pointcut）：切点是指通知（Advice）所要织入（Weaving）的具体位置。

### 通知类型

![image-20200712211219006](总结.assets/image-20200712211219006.png)

### 织入时机

![image-20200712211243905](总结.assets/image-20200712211243905.png)

- 其中，编译器和类加载期织入需要编译器的支持，Spring只支持运行期织入

### 代码一览

#### 两种配置文件

##### 注解形式

```java
@Configuration
@EnableAspectJAutoProxy //开启AspectJ的自动代理机制
@ComponentScan
public class ConcertConfig {
    @Bean
    public Audience2 audience() { //要织入的代码
        return new Audience2();
    }

    @Bean
    public Performance concert() { //被织入的代码
        return new Concert();
    }

    @Bean
    public EncoreableIntroducer encoreableIntroducer() { //要增加的方法实例
        return new EncoreableIntroducer();
    }
}
```

##### XML形式

```xml
<aop:aspectj-autoproxy/>
<bean class="concert.Audience"/>
<bean id="concert" class="concert.Concert"/>
```



#### 注解驱动的切面

##### 普通切面

```java
@Aspect
public class Audience {
    @Before("execution(* concert.Performance.perform( .. ))")
    public void silenceCellPhones() {
        System.out.println("Silencing cell phones");
    }

    @Before("execution(* concert.Performance.perform( .. ))")
    public void takeSeats() {
        System.out.println("Taking seats");
    }

    @AfterReturning("execution(* concert.Performance.perform( .. ))")
    public void applause() {
        System.out.println("CLAP CLAP CLAP!!!");
    }

    @AfterThrowing("execution(* concert.Performance.perform( .. ))")
    public void demandRefund() {
        System.out.println("Demand a refund");
    }
}
```

##### 提取了pointcut的切面

```java
@Aspect
public class Audience1 {
    @Pointcut("execution(* concert.Performance.perform( .. ))")
    public void performance() {
    }

    @Before("performance()")
    public void silenceCellPhones() {
        System.out.println("Silencing cell phones");
    }
}
```

##### @Around 标签

```java
@Aspect
public class Audience2 {
    @Pointcut("execution(* concert.Performance.perform( .. ))")
    public void performance() {
    }

    @Around("performance()")  /* 包围 */
    public void watchPerformance(ProceedingJoinPoint joinPoint) {
        try {
            System.out.println(".Silencing cell phones");
            System.out.println(".Taking seats");
            joinPoint.proceed();  // 方法调用(可以调用多次)
            System.out.println(".CLAP CLAP CLAP!!!");
        } catch (Throwable e) {
            System.out.println(".Demanding a refund");
        }
    }
}
```

##### 给类增添接口

```java
public interface Encoreable { //接口
    void performEncore();
}
=======================
public class DefaultEncoreable implements Encoreable { //实例
    public void performEncore() {
        System.out.println("perform the encore!");
    }
}   
=======================
@Aspect
public class EncoreableIntroducer { 
    @DeclareParents(value = "concert.Performance+", //要增加接口的类
            defaultImpl = DefaultEncoreable.class) //要增加的接口的实例
    public static Encoreable encoreable; //增加的接口
}
```

##### 给带参数的方法增加切面

```java
//需要增加切面的方法
public interface CompactDisc {
    void playTrack(int num);
}

====================================
//切面
@Aspect
public class TrackCounter {
    private Map<Integer, Integer> trackCounts = new HashMap<Integer, Integer>();

    @Pointcut(
            "execution(* soundsystem.CompactDisc.playTrack( int )) " +
                    "&& args(trackNumber)") //这一行很关键
    public void trackPlayed(int trackNumber) {
    }

    @Before("trackPlayed(trackNumber)")
    public void countTrack(int trackNumber) {
        int currentCount = getPlayCount(trackNumber);
        trackCounts.put(trackNumber, currentCount + 1);
    }

    public int getPlayCount(int trackNumber) {
        return trackCounts.containsKey(trackNumber) ? trackCounts.get(trackNumber) : 0;
    }
}
```



#### 纯POJO切面（XML）

##### 普通切面

```xml
<aop:aspectj-autoproxy/>

<bean id="audience" class="concert2.Audience"/>
<bean id="concert" class="concert.Concert"/>

<aop:config>
    <aop:aspect ref="audience">
        <aop:before method="silenceCellPhones"
                    pointcut="execution(* concert.Performance.perform(..))"/>
        <aop:before method="takeSeats"
                    pointcut="execution(* concert.Performance.perform(..))"/>
        <aop:after method="applause"
                   pointcut="execution(* concert.Performance.perform(..))"/>
        <aop:after-throwing method="demandRefund"
                            pointcut="execution(* concert.Performance.perform(..))"/>
    </aop:aspect>
</aop:config>
```

##### 提取了pointcut的切面

```xml
<aop:aspectj-autoproxy/>

    <bean id="audience" class="concert2.Audience"/>
    <bean id="concert" class="concert.Concert"/>

    <aop:config>
        <aop:aspect ref="audience">
            <aop:pointcut id="performance"
                          expression="execution(* concert.Performance.perform(..))"/>

            <aop:before method="silenceCellPhones"
                        pointcut-ref="performance"/>

            <aop:before method="takeSeats"
                        pointcut-ref="performance"/>

            <aop:after method="applause"
                       pointcut-ref="performance"/>

            <aop:after-throwing method="demandRefund"
                                pointcut-ref="performance"/>
        </aop:aspect>
    </aop:config>
```

##### around

```xml
<aop:aspectj-autoproxy/>

<bean id="audience" class="concert2.Audience2"/>
<bean id="concert" class="concert.Concert"/>

<aop:config>
    <aop:aspect ref="audience">
        <aop:pointcut id="performance"
                      expression="execution(* concert.Performance.perform(..))"/>

        <!--其实跟其他几个写法一模一样，只是具体方法需要携带 ProceedingJoinPoint类型的参数-->
        <aop:around method="watchPerformance"
                    pointcut-ref="performance"/>
    </aop:aspect>
</aop:config>
```

##### 给类增添接口

```xml
<aop:aspectj-autoproxy/>

<bean id="concert" class="concert.Concert"/>

<aop:config>
    <aop:aspect>
        <aop:declare-parents types-matching="concert.Performance+"
                             implement-interface="concert.Encoreable"
                             default-impl="concert.DefaultEncoreable"/>
        <!--DefaultEncoreable不需要实例化-->
    </aop:aspect>
</aop:config>
```

##### 给带参数的方法增加切面

```xml
<aop:aspectj-autoproxy/>

<bean id="trackCounter" class="soundsystem2.TrackCounter"/>
<bean id="cd" class="soundsystem.BlankDisc">
    ...
</bean>

<aop:config>
    <aop:aspect ref="trackCounter">
        <aop:pointcut id="trackPlayed"
                      expression="execution(* soundsystem.CompactDisc.playTrack(int)) and args(trackNumber)"/>

        <aop:before method="countTrack"
                    pointcut-ref="trackPlayed"/>
    </aop:aspect>
</aop:config>
```



## 第4节 Web开发框架（MVC、控制器、视图渲染）

### 软件体系架构（C/S,B/S）

![image-20200712231845659](总结.assets/image-20200712231845659.png)





### 服务端开发的一般架构

![image-20200712233236351](总结.assets/image-20200712233236351.png)

### 追踪SpringMVC的请求

![image-20200712233519765](总结.assets/image-20200712233519765.png)

### DispatchServlet配置[^2]

- 以下内容建议对照

  [^1]: 应用的XML配置

![image-20200712233558814](总结.assets/image-20200712233558814.png)

![image-20200712233724623](总结.assets/image-20200712233724623.png)

想了半天，发现这个的意思是 `AbstractAnnotationConfigDispatcherServletInitializer` 这玩意儿使用了两个类——`ContextLoaderListener` 和 `DispatcherServlet` , 在Servlet3之前，这两个类就存在了，但是是在web.xml里面配置的，具体配置如下( section1的web.xml )

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5"
         xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
	http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">
<!--    配置上下文-->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:applicationContext.xml</param-value>
    </context-param>
    <listener>
        <listener-class>
            org.springframework.web.context.ContextLoaderListener
        </listener-class>
    </listener>

<!--    配置servlet-->
    <servlet>
        <servlet-name>viewspace</servlet-name>
        <servlet-class>
            org.springframework.web.servlet.DispatcherServlet
        </servlet-class>
        <load-on-startup>3</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>viewspace</servlet-name>
        <url-pattern>*.html</url-pattern>
    </servlet-mapping>
</web-app>
```

而现在只需要像下面这么写

```java
import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;
import example.web.WebConfig;

public class AddressBookWebInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class<?>[]{RootConfig.class}; //上下文配置
    }

    @Override
    protected Class<?>[] getServletConfigClasses() { //servlet配置
        return new Class<?>[]{WebConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```

其中，RootConfig.java如下

```java
@Configuration
@Import(DataConfig.class) //导入数据源的配置
@ComponentScan(basePackages = {"example"}, //实例化example下面的Component
        excludeFilters = {
                @Filter(type = FilterType.CUSTOM, value = WebPackage.class) //不实例化web包下面的Component
        })
public class RootConfig {
    public static class WebPackage extends RegexPatternTypeFilter {
        public WebPackage() {
            super(Pattern.compile("example\\.web"));
        }
    }
}
```

DataConfig.java如下

```java
@Configuration
public class DataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.H2) //H2，一般用来做测试用
                .addScript("schema.sql")
                .build();
    }

    @Bean
    public JdbcOperations jdbcTemplate(DataSource dataSource) {
        return new JdbcTemplate(dataSource);
    }

}
```

![image-20200713001748146](总结.assets/image-20200713001748146.png)

WebConfig.java如下

```java
@Configuration
@EnableWebMvc //允许使用MVC组件
@ComponentScan("example.web") //组件扫描，实例化Controller类
public class WebConfig extends WebMvcConfigurerAdapter {

    @Bean
    public ViewResolver viewResolver() { //配置视图解析器
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/views/");
        resolver.setSuffix(".jsp");
        return resolver;
    }

    @Override /** 默认静态资源处理器（不考） **/
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }

    @Override /** 静态资源处理（不考） **/
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // TODO Auto-generated method stub
        super.addResourceHandlers(registry);
    }

}
```

`WebMvcConfigurerAdapter` 这个类可以解决跨域问题、添加拦截器、配置视图解析器、静态资源处理等等，有些许的复杂，老师也没讲过这个，并且Spring5.0已经废弃该类，因此我认为他不会考。。

“排除静态资源请求” 是啥意思我不太清楚，我猜测指的是静态资源处理。

### 控制器（Controller）的实现

```java
@Controller //实际上等价于@Component
@RequestMapping("/person")
public class PersonController {

    private static final String MAX_LONG_AS_STRING = "9223372036854775807";

    private PersonRepository personRepository;

    @Autowired
    public PersonController(PersonRepository personRepository) { //构造器注入，另外这个构造函数在Controller测试时会使用到，那时候会传入一个MockRepository
        this.personRepository = personRepository;
    }

    /* 请求参数（带默认值）、model */
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    public String persons(
            @RequestParam(value = "max", defaultValue = MAX_LONG_AS_STRING) long max, Model model) {
        model.addAttribute(personRepository.findPersons(max));//省去了第一个参数“personList”
        return "list"; //返回视图名
    }

    /* 路径参数 */
    @RequestMapping(value = "/{name}", method = RequestMethod.GET)
    public String person(
            @PathVariable("name") String name,//同名时，value可以去除
            Model model) {
        model.addAttribute(personRepository.findByName(name));
        return "person";
    }

    /* 空的表单 */
    @RequestMapping(value = "/add", method = GET)
    public String showRegistrationForm(Model model) {
        model.addAttribute(new Person()); //空的Person，在视图上显示为空字段
        return "personForm";
    }

    /* 表单参数，字段验证 */
    @RequestMapping(value = "/add", method = RequestMethod.POST)
    public String savePerson(@Valid Person person, Errors errors) throws Exception {
        //这里表单提交时需要提交的form字段和Person的字段保持一致（默认处理），不一致可能需要其他操作
        if (errors.hasErrors()) { //验证出错会接收到Errors（怎么接收到的不太清楚）
            return "personForm";
        }
        personRepository.save(person);
        return "redirect:/person/list"; //重定向
    }
	
    ...

}

```

表单校验需要在**需要校验的类**上面添加@NotNull、@Size等校验标签，并且在控制器传参的位置加上@Valid标签。有一些error信息需要写到 `resources/ValidationMessages.properties` 当中。

- Person.java

```java
public class Person {

    private Long id;

    @NotNull
    @Size(min = 5, max = 20,message="{name.size}")
    private String name;

    @NotNull
    @Size(min = 2, max = 100,message="{address.size}")
    private String address;
 	
    ...

}
```

- resources/ValidationMessages.properties

```properties
name.size=name must be between {min} and {max} characters long.
address.size=address must be between {min} and {max} characters long.
zipCode.size=zipCode must be between {min} and {max} characters long.
phone.size=phone must be between {min} and {max} characters long.
```



### 控制器（Controller）的测试

测试这玩意儿看起来很玄妙，不过大体的步骤如下

- mock 一下dao层
- new出一个Controller
- 通过该Controller建立MockMvc
- MockMvc模拟请求，传入请求参数
- MockMvc验证一下Controller返回的视图对不对、有没有重定向、得到的model数据对不对等等
- 也可以验证一下Controller层有没有调用到dao层

代码如下，自己品。。

```java
package example.web;

import org.junit.Test;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.web.servlet.view.InternalResourceView;
import example.Person;
import example.data.PersonRepository;

import java.util.ArrayList;
import java.util.List;

import static org.hamcrest.Matchers.hasItems;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;
import static org.springframework.test.web.servlet.setup.MockMvcBuilders.standaloneSetup;

public class PersonControllerTest {

    @Test
    public void shouldShowAllPersons() throws Exception {
        List<Person> expectedPersons = createPersonList(20);
        PersonRepository mockRepository = mock(PersonRepository.class);
        when(mockRepository.findPersons(Long.MAX_VALUE))
                .thenReturn(expectedPersons);

        PersonController controller = new PersonController(mockRepository);
        MockMvc mockMvc = standaloneSetup(controller)
                .setSingleView(new InternalResourceView("/WEB-INF/views/list.jsp"))
                .build();

        mockMvc.perform(get("/person/list"))
                .andExpect(view().name("list"))
                .andExpect(model().attributeExists("personList"))
                .andExpect(model().attribute("personList",
                        hasItems(expectedPersons.toArray())));
    }

    @Test
    public void shouldShowFilterPersons() throws Exception {
        List<Person> expectedPersons = createPersonList(50);
        PersonRepository mockRepository = mock(PersonRepository.class);
        when(mockRepository.findPersons(50))
                .thenReturn(expectedPersons);

        PersonController controller = new PersonController(mockRepository);
        MockMvc mockMvc = standaloneSetup(controller)
                .setSingleView(new InternalResourceView("/WEB-INF/views/list.jsp"))
                .build();

        mockMvc.perform(get("/person/list?max=50"))
                .andExpect(view().name("list"))
                .andExpect(model().attributeExists("personList"))
                .andExpect(model().attribute("personList",
                        hasItems(expectedPersons.toArray())));
    }

    @Test
    public void testPerson() throws Exception {
        Person expectedPerson = new Person("Name", "abc", "111111", "77777777777");
        PersonRepository mockRepository = mock(PersonRepository.class);
        when(mockRepository.findByName("zhangsan")).thenReturn(expectedPerson);

        PersonController controller = new PersonController(mockRepository);
        MockMvc mockMvc = standaloneSetup(controller).build();

        mockMvc.perform(get("/person/zhangsan"))
                .andExpect(view().name("person"))
                .andExpect(model().attributeExists("person"))
                .andExpect(model().attribute("person", expectedPerson));
    }

    @Test
    public void addPerson() throws Exception {
        PersonRepository mockRepository = mock(PersonRepository.class);
        PersonController controller = new PersonController(mockRepository);
        MockMvc mockMvc = standaloneSetup(controller).build();

        mockMvc.perform(post("/person/add")
                .param("name", "name123")
                .param("address", "this is address")
                .param("zipCode", "123456")
                .param("phone", "12345678900"))
                .andExpect(redirectedUrl("/person/list"));

        verify(mockRepository, atLeastOnce()).save(new Person("name123", "this is address", "123456", "12345678900"));
    }

    private List<Person> createPersonList(int count) {
        List<Person> persons = new ArrayList<>();
        for (int i = 0; i < count; i++) {
            persons.add(new Person("Person " + i, "abcdefghijiadiididid", "212001", "13377777777"));
        }
        return persons;
    }
}

```



## 第5节 Spring Web Flow

### Servlet简单介绍

#### servlet配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">
    <!--   实现servlet -->
    <display-name>hello</display-name>

    <!-- servlet部署 -->
    <servlet>
        <!--给servlet取名，任意 -->
        <servlet-name>hello1</servlet-name>
        <!-- 指明servlet路径，包名.类名 -->
        <servlet-class>example.MyServlet1</servlet-class>
    </servlet>

    <servlet-mapping>
        <!--servlet映射，必须与servlet-name同名 -->
        <servlet-name>hello1</servlet-name>
        <!--这是浏览器中输入的访问该servlet的url-->
        <url-pattern>/s1</url-pattern>
    </servlet-mapping>

    <!--指定为哪些url配置过滤器-->
    <filter>
        <filter-name>MyFilter</filter-name>
        <filter-class>example.MyFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>MyFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
</web-app>


```

#### Servlet 代码

##### 最原始版本

```java
package example;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.Servlet;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class MyServlet1 implements Servlet { //实现servlet接口

    @Override
    public void destroy() {
        System.out.println("destroy");
    }

    @Override
    public ServletConfig getServletConfig() {
        return null;
    }

    @Override
    public String getServletInfo() {
        return null;
    }

    @Override
    public void init(ServletConfig arg0) throws ServletException {
        System.out.println("init it in servlet");
    }

    @Override
    public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {
        System.out.println("service1...");

        //打印在浏览器上
        PrintWriter pw = response.getWriter();
        pw.println("hello,this is servlet1");
    }

}

```

##### 进行了简单封装

```java
package example;

import javax.servlet.GenericServlet;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import java.io.IOException;
import java.io.PrintWriter;


public class MyServlet2 extends GenericServlet { //继承GenericServlet，其对Servlet接口进行了简单实现，因此不用再写一堆override

    @Override
    public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException {
        System.out.println("service2...");
        PrintWriter pw = response.getWriter();
        pw.println("hello,this is a GenericServlet");
    }
}

```

##### 实现了http协议

```java
package example;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
//import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

//@WebServlet("/s3")
public class MyServlet3 extends HttpServlet { //进一步实现了http协议
    private static final long serialVersionUID = 1L;

    public MyServlet3() {
        super();
    }

    //处理get请求
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        PrintWriter pw = response.getWriter();
        pw.println("hello,this is a HttpServlet");
    }

    //处理post请求
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request, response);
    }

}

```

##### filter代码

```java
package example;

import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;

public class MyFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("my filter init....");
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
                         FilterChain chain) throws IOException, ServletException {
        System.out.println(" do filter before enter servlet......");
        chain.doFilter(request, response); //调用下一个filter
        System.out.println(" do filter after finishing servlet......");
    }

    @Override
    public void destroy() {
        System.out.println("my filter destroy....");
    }

}
```

### WebFlow

#### 用途

- 开发基于**流程**的应用程序 
- 将**流程定义**、**实现流程行为**的**类和视图**分离开来。

#### 目录结构

- java代码还是在src目录下面，包括domain、service和controller等，和普通的mvc项目一致
- 在webflow项目里面仍然可以写mvc代码，只要你配置了mvc（参见上一章节），或者说webflow和mvc不冲突，可以配合着完成任务。你甚至可以在spring框架里面写原生servlet，如果需要的话。

![image-20200714202354819](总结.assets/image-20200714202354819.png)

#### webflow配置

- 流程执行器（flow executor）
- 流程注册表（flow registry）
- 配置FlowHandlerMapping
- FlowHandlerAdapter

##### 代码如下

###### web.xml

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>

<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
         version="3.1">


<!-- 仍然需要配置上下文和servlet，和第一节的配置没啥区别 -->
 <context-param>
  <param-name>contextConfigLocation</param-name>
  <param-value>/WEB-INF/spring/root-config.xml</param-value>
 </context-param>

 <listener>
  <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
 </listener>

 <servlet>
  <servlet-name>SpringPizza</servlet-name>
  <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
  <init-param>
  	<param-name>contextConfigLocation</param-name> <!-- 这里相当于servlet的配置环境跟context一致（我猜的）-->
       <param-value/>
  </init-param>
  <load-on-startup>1</load-on-startup>
 </servlet>

 <servlet-mapping>
  <servlet-name>SpringPizza</servlet-name>
  <url-pattern>/</url-pattern>
 </servlet-mapping>
 
</web-app>
```

###### root-config.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd">

	<import resource="mvc.xml" /> <!--mvc的配置-->
	<import resource="flow.xml" /> <!--webflow的配置-->
	<import resource="services.xml" />
	<import resource="domain.xml" />
	<import resource="dataaccess.xml" />

	<context:component-scan base-package="com.springinaction.pizza" />
	
</beans>
```

###### mvc.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd
		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

  <mvc:annotation-driven />

  <!-- 配了个视图解析器 -->
  <bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <property name="prefix" value="/WEB-INF/jsp/" />
    <property name="suffix" value=".jsp" />
  </bean>

</beans>

```

###### flow.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xmlns:flow="http://www.springframework.org/schema/webflow-config"
 xmlns:p="http://www.springframework.org/schema/p"
 xmlns:context="http://www.springframework.org/schema/context"
 xsi:schemaLocation="http://www.springframework.org/schema/webflow-config 
   http://www.springframework.org/schema/webflow-config/spring-webflow-config-2.3.xsd
   http://www.springframework.org/schema/beans 
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/context 
   http://www.springframework.org/schema/context/spring-context-3.0.xsd">

  <context:component-scan base-package="com.springinaction.pizza.flow" />


    <!-- ============= 括号里的内容是老师视频上的中文注释，括号前面的是我的理解 ============= -->
    
  <!-- The registry of executable flow definitions -->
  <!-- 找到要注册的流的位置（配置流程注册表，用于加载流程定义） -->
  <flow:flow-registry id="flowRegistry" 
           base-path="/WEB-INF/flows">
     <flow:flow-location-pattern value="/**/*-flow.xml" />
  </flow:flow-registry>

  <!--Maps request paths to flows in the flowRegistry-->
  <!--请求路径和注册的流的映射，这里应该是默认映射（将请求导向到Spring Web Flow）-->
  <bean class="org.springframework.webflow.mvc.servlet.FlowHandlerMapping">
    <property name="flowRegistry" ref="flowRegistry" />
  </bean>


  <!-- Executes flows: the entry point into the Spring Web Flow system -->
  <!-- webflow的入口（装配流程执行器）-->
  <flow:flow-executor id="flowExecutor" />

  <!-- Dispatches requests mapped to flows to FlowHandler implementations -->
  <!-- 类似controller一样的东西，含有属性flow-executor （处理请求，类似控制器）-->
  <bean class="org.springframework.webflow.mvc.servlet.FlowHandlerAdapter">
    <property name="flowExecutor" ref="flowExecutor" />
  </bean>

</beans>

```

#### 流程三元素

##### 状态 （State）

- 视图（View）

```xml
<view-state id="welcome">
    <transition on="phoneEntered" to="lookupCustomer"/>
    <transition on="cancel" to="cancel"/>
</view-state>
```



- 行为（Action） SpEL表达式

```xml
<action-state id="addCustomer">
    <evaluate expression="pizzaFlowActions.addCustomer(order.customer)" />
    <transition to="customerReady" />
</action-state>
```



- 决策（Decision）

```xml
<decision-state id="checkDeliveryArea">
    <if test="pizzaFlowActions.checkDeliveryArea(order.customer.zipCode)" 
        then="addCustomer" 
        else="deliveryWarning"/>
</decision-state>
```



- 子流程（Subflow）

```xml
<subflow-state id="customer" subflow="pizza/customer">
    <input name="order" value="order"/> <!--给子流程初始化变量-->
    <transition on="customerReady" to="order" />
</subflow-state>
```



- 结束（End） 注意可能不止一个结束状态

```xml
<end-state id="cancel" />
<end-state id="customerReady" />
```



##### 转移（transition）

- to  目标状态 
- on  事件 

```xml
<view-state id="welcome">
    <transition on="phoneEntered" to="lookupCustomer"/>
    <transition on="cancel" to="cancel"/>
</view-state>
```



- on-exception   异常 

```xml
<action-state id="lookupCustomer">
    <evaluate result="order.customer" expression=
              "pizzaFlowActions.lookupCustomer(requestParameters.phoneNumber)" />
    <transition to="registrationForm" on-exception=
                "com.springinaction.pizza.service.CustomerNotFoundException" />
    <transition to="customerReady" />
</action-state>
```



- 全局转移：global-transitions

```xml
<global-transitions>
    <transition on="cancel" to="endState" />
</global-transitions>
```



##### 流程数据

- 创建变量的3种方式 
  - `<var name="order" class="com.springinaction.pizza.domain.Order"/>` ——flow
  - `<evaluate result="viewScope.paymentTypeList" expression="T(com.springinaction.pizza.domain.PaymentType).asList()" />` ——flow或view
  - `<set name="flowScope.pizza" value="new com.springinaction.pizza.domain.Pizza()" />` ——flow或者view
- 作用域 
  -  Flow（当前流程有效）
  -  View（当前视图有效）

#### JSP部分

```jsp
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
<html>

  <head><title>Spring Pizza</title></head>

  <body>
    <h2>Customer Registration</h2>
    
    <form:form commandName="order">
        
      <input type="hidden" name="_flowExecutionKey" 
             value="${flowExecutionKey}"/> 
        <!--这个隐藏的input用来区分流程执行到了哪一步-->
        
      <b>Phone number: </b><form:input path="customer.phoneNumber"/><br/>
      <b>Name: </b><form:input path="customer.name"/><br/>
      <b>Address: </b><form:input path="customer.address"/><br/>
      <b>City: </b><form:input path="customer.city"/><br/>
      <b>State: </b><form:input path="customer.state"/><br/>
      <b>Zip Code: </b><form:input path="customer.zipCode"/><br/>
        
      <input type="submit" name="_eventId_submit"  
             value="Submit" />
        <!--name用来区分事件，这里的submit、cancel等对应着xml里面的on事件-->
        
      <input type="submit" name="_eventId_cancel" 
             value="Cancel" />
    </form:form>
	</body>
</html>
```

<u>其他细节参见section5源码</u>



## 第6节 JDBC

### 业务与访问持久化数据解耦

- 数据访问对象（data access object，DAO）或者Repository（持久化对象）

![image-20200716003806977](总结.assets/image-20200716003806977.png)

- 抽象出Repository接口的好处
  - 方便测试
  - 方便替换数据访问层

### 异常体系

![image-20200716004052589](总结.assets/image-20200716004052589.png)

- 其中SQLException是jdbc默认抛出的异常 （是一种非运行时异常，需要抛出或者try catch，区别于RuntimeException）
- RuntimeException可以回滚
- DataAccessException是一种运行时异常（Spring框架将所有SQLException转换为DataAccessException）
- 不同的数据库访问技术会提供不同的异常的实现，比如说Hibernate框架提供了自己的异常，我们需要屏蔽这种差异性，所以Spring框架统一会抛出DataAccessException异常

### 模板方法模式

![image-20200716005327186](总结.assets/image-20200716005327186.png)

### 四种配置数据源的方式

![image-20200716005540458](总结.assets/image-20200716005540458.png)

#### 通过JNDI查找的数据源

![image-20200716005931508](总结.assets/image-20200716005931508.png)

- Spring —— java config配置

```java
@Bean
public JndiObjectFactoryBean dataSource0() {
    JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean();
    jndiObjectFactoryBean.setJndiName("jdbc/person"); //这一行是关键
    jndiObjectFactoryBean.setResourceRef(true);
    jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class);
    return jndiObjectFactoryBean;
}
// JNDI方式获取数据源按理来讲需要下面这个方法获取DataSource，但是老师的源码上面没有这个方法
// 见 https://my.oschina.net/loveall/blog/797693?from=liebao_fast&did=null
@Bean
public DataSource dataSource(JndiObjectFactoryBean dataSourceFactory) {
    return (DataSource) dataSourceFactory.getObject();
}
```

- Tomcat容器的配置

![image-20200716005916676](总结.assets/image-20200716005916676.png)

#### 第三方提供的数据源连接池实现

![image-20200716010151147](总结.assets/image-20200716010151147.png)

- java配置 

```java
@Bean
public DataSource dataSource3() {
    BasicDataSource ds = new BasicDataSource(); // BasicDataSource (org.apache.commons.dbcp)
    ds.setDriverClassName("com.mysql.jdbc.Driver");
    ds.setUrl("jdbc:mysql://localhost:3306/exampledb6");
    ds.setUsername("root");
    ds.setPassword("exampledb20");
    ds.setInitialSize(5);
    ds.setMaxActive(10);
    return ds;
}
```

- xml配置

```xml
<beans profile="prod">
    <bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"
          destroy-method="close"
          p:driverClassName="com.mysql.jdbc.Driver"
          p:url="jdbc:mysql://localhost:3306/exampledb6"
          p:username="root"
          p:password="exampledb20"/>
</beans>
```



#### 通过JDBC驱动程序定义的数据源

![image-20200716010539862](总结.assets/image-20200716010539862.png)

- java配置

```java
@Bean
public DataSource dataSource2() {
    DriverManagerDataSource ds = new DriverManagerDataSource();
    ds.setDriverClassName("com.mysql.jdbc.Driver");
    ds.setUrl("jdbc:mysql://localhost:3306/exampledb6");
    ds.setUsername("root");
    ds.setPassword("exampledb20");
    return ds;
}
```

- xml配置

```xml
<beans profile="qa">
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"
          p:driverClassName="com.mysql.jdbc.Driver"
          p:url="jdbc:mysql://localhost:3306/exampledb6"
          p:username="root"
          p:password="exampledb20"/>
</beans>
```



#### 配置嵌入式数据源

![image-20200716010822649](总结.assets/image-20200716010822649.png)

- java配置

```java
@Bean
public DataSource dataSource() {
    return new EmbeddedDatabaseBuilder()
        .setType(EmbeddedDatabaseType.H2)
        .addScripts("classpath:com/example/db/jdbc/schema.sql", "classpath:com/example/db/jdbc/test-data.sql")
        .build();
}
```

- xml配置

```xml
<beans profile="dev">
    <jdbc:embedded-database id="dataSource" type="H2">
        <jdbc:script location="classpath:com/example/db/jdbc/schema.sql"/>
        <jdbc:script location="classpath:com/example/db/jdbc/test-data.sql"/>
    </jdbc:embedded-database>
</beans>
```

### 使用profile选择数据源

- 建立开发、测试、生产环境的不同数据源

```java
@Profile("dev")
@Bean
public DataSource dataSource() {
    ...
}
```

```xml
<beans profile="dev">
    ...
</beans>
```

### Spring的JDBC框架

![image-20200716011234657](总结.assets/image-20200716011234657.png)

#### JdbcTemplate

- 配置

```java
@Bean
public JdbcTemplate jdbcTemplate(DataSource dataSource) {
    return new JdbcTemplate(dataSource);
}
```



- 使用

```java
// 网上找的，主要是跟 NamedParameterJdbcTemplate 做一下对比
public static void test02() throws Exception {
    JdbcTemplate jdbcTemplate = new JdbcTemplate(DataSourceUtils.getDataSource());
    String sql = "UPDATE product SET pname=?, price=? WHERE pid=?;";
    int i = jdbcTemplate.update(sql, "XVIII", 18888, 10); //不带名字，按顺序传参
    System.out.println("影响的行数: " + i);
}
```



#### NamedParameterJdbcTemplate

- 配置

```java
@Bean
public NamedParameterJdbcTemplate namedJdbcTemplate(DataSource dataSource) {
    return new NamedParameterJdbcTemplate(dataSource);
}
```



- 使用

```java
package com.example.db.jdbc;

import ...

@RunWith(SpringJUnit4ClassRunner.class)
@ActiveProfiles("qa") //激活的环境!!
@ContextConfiguration(classes = JdbcConfig.class)
public class NamedJdbcTemplateTest {

    @Autowired
    private NamedParameterJdbcTemplate namedJdbcTemplate;

    private static final String SQL_INSERT_CUSTOMER =
            "insert into customer (name, address, city, email) values (:name,:address,:city,:email)"; //带名字，根据名字传参

    @Test
	@Transactional //用于开启事务
    public void addCustomer() {
        Map<String, Object> paramMap = new HashMap<>();

        paramMap.put("name", "taozs");
        paramMap.put("address", "address88");
        paramMap.put("city", "nanjing");
        paramMap.put("email", "tzs@163.com");

        namedJdbcTemplate.update(SQL_INSERT_CUSTOMER, paramMap);
    }
}
```

### 代码一览

#### 原始的jdbc

```java
import ...
    
@RunWith(SpringJUnit4ClassRunner.class)
@ActiveProfiles("qa")
@ContextConfiguration(classes = JdbcConfig.class)
public class originalJdbcTest {

    @Autowired
    private DataSource dataSource;

    private static final String SQL_INSERT_CUSTOMER =
            "insert into customer (name, address, city, email) values (?,?,?,?)";

    @Test
    public void addCustomer() { //看起来就巨麻烦

        Connection conn = null;
        PreparedStatement stmt = null;

        try {
            conn = dataSource.getConnection();
            stmt = conn.prepareStatement(SQL_INSERT_CUSTOMER);

            stmt.setString(1, "taozs");
            stmt.setString(2, "address88");
            stmt.setString(3, "nanjing");
            stmt.setString(4, "tzs@163.com");

            stmt.execute();

        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

```

#### 使用了模板的jdbc

```java
import ...
    
public class JdbcCustomerRepository implements CustomerRepository {

    private JdbcTemplate jdbcTemplate;

    public JdbcCustomerRepository(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    public long count() { //查
        return jdbcTemplate.queryForObject("select count(id) from customer", Long.class); //指定返回值类型
    }

    public Customer save(Customer customer) {
        Long id = customer.getId();
        if (id == null) {
            long customerId = insertCustomerAndReturnId(customer);
            return new Customer(customerId, customer.getName(), customer.getAddress(), customer.getCity(), customer.getEmail());
        } else {//改
            jdbcTemplate.update("update customer set name=?, address=?, city=?, email=? where id=?",
                    customer.getName(),
                    customer.getAddress(),
                    customer.getCity(),
                    customer.getEmail(),
                    id);
        }
        return customer;
    }

    private long insertCustomerAndReturnId(Customer customer) { //增
        //能插入数据并返回生成的Id
        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate).withTableName("customer");
        jdbcInsert.setGeneratedKeyName("id");
        Map<String, Object> args = new HashMap<>();
        args.put("name", customer.getName());
        args.put("address", customer.getAddress());
        args.put("city", customer.getCity());
        args.put("email", customer.getEmail());
        long customerId = jdbcInsert.executeAndReturnKey(args).longValue();
        return customerId;
    }


    @SuppressWarnings("unused")
    private void insertCustomer(Customer customer) {
        jdbcTemplate.update(INSERT_CUSTOMER,
                customer.getName(),
                customer.getAddress(),
                customer.getCity(),
                customer.getEmail());
    }

    public Customer findOne(long id) {
	return jdbcTemplate.queryForObject(
			SELECT_CUSTOMER + " where id=?", new CustomerRowMapper(), id);
//        (rs, rowNum)->{ // RowMapper接口只有一个方法，可以用λ表达式替换
//
//        }
        
//        return jdbcTemplate.queryForObject(
//                SELECT_CUSTOMER + " where id=?", this::mapCustomer, id); //不是很懂为啥可以这么换
    }

    public Customer findByName(String name) {
        return jdbcTemplate.queryForObject("select id, name, address, city, email from Customer where name=?", new CustomerRowMapper(), name);
    }

    public List<Customer> findAll() {
        return jdbcTemplate.query("select id, name, address, city, email from Customer order by id", new CustomerRowMapper());
    }

    private static final class CustomerRowMapper implements RowMapper<Customer> {
        public Customer mapRow(ResultSet rs, int rowNum) throws SQLException { //自行构造返回的对象（或对象列表）
            long id = rs.getLong("id");
            String name = rs.getString("name");
            String address = rs.getString("address");
            String city = rs.getString("city");
            String email = rs.getString("email");
            return new Customer(id, name, address, city, email);
        }
    }

    public Customer mapCustomer(ResultSet rs, int rowNum) throws SQLException {
        long id = rs.getLong("id");
        String name = rs.getString("name");
        String address = rs.getString("address");
        String city = rs.getString("city");
        String email = rs.getString("email");
        return new Customer(id, name, address, city, email);
    }

    private static final String INSERT_CUSTOMER = "insert into Customer (name, address, city, email) values (?, ?, ?, ?)";

    private static final String SELECT_CUSTOMER = "select id, name, address, city, email from Customer";

}

```

```java
public void delete(long id) { //删
    jdbcTemplate.update("delete from cargo where id=?", id);
}
```

#### 其他

- 要开启事务的话还得配置事务

```java
@Bean
public PlatformTransactionManager transactionManager(DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
}
```



## 第7节 ORM、Hibernate与JPA编程

![image-20200716232313937](总结.assets/image-20200716232313937.png)

- JDBC模板需要自己构建领域对象，而ORM框架不需要操心领域对象和表的对应关系，不用关心领域对象是如何创建的，不用关心表和表之间的一对多或者多对一的关系是如何维护的

### ORM

![image-20200716233051281](总结.assets/image-20200716233051281.png)

- JPA是java 借鉴市面上的各种ORM框架而实现的一套 **规范**
- Hibernate 也支持JPA规范

### Hibernate

#### Hibernate配置

![image-20200716233622756](总结.assets/image-20200716233622756.png)

##### 配置文件

```java
package com.example.db.hibernate4;

import org.hibernate.SessionFactory;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabase;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;
import org.springframework.orm.hibernate4.HibernateTransactionManager;
import org.springframework.orm.hibernate4.LocalSessionFactoryBean;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.transaction.annotation.TransactionManagementConfigurer;

import javax.inject.Inject;
import javax.sql.DataSource;
import java.io.IOException;
import java.util.Properties;

@Configuration
@EnableTransactionManagement
@ComponentScan
public class RepositoryTestConfig implements TransactionManagementConfigurer {

  @Inject //和Autowired接口一个意思，不过这个是java自己实现的，而Autowired是Spring框架实现的
  private SessionFactory sessionFactory;

  @Bean
  public DataSource dataSource() { //数据源
    EmbeddedDatabaseBuilder edb = new EmbeddedDatabaseBuilder();
    edb.setType(EmbeddedDatabaseType.H2);
    edb.addScript("com/example/db/hibernate4/schema.sql");
    edb.addScript("com/example/db/hibernate4/test-data.sql");
    EmbeddedDatabase embeddedDatabase = edb.build();
    return embeddedDatabase;
  }

  public PlatformTransactionManager annotationDrivenTransactionManager() { //事务管理器
    HibernateTransactionManager transactionManager = new HibernateTransactionManager();
    transactionManager.setSessionFactory(sessionFactory);
    return transactionManager;
  }

  @Bean
  public SessionFactory sessionFactoryBean() { //session工厂
    try {
      LocalSessionFactoryBean lsfb = new LocalSessionFactoryBean();
      lsfb.setDataSource(dataSource());
      lsfb.setPackagesToScan("com.example.domain"); //领域对象所在的包名
      Properties props = new Properties();
      props.setProperty("dialect", "org.hibernate.dialect.H2Dialect"); //设置sql方言
//      props.setProperty("dialect", "org.hibernate.dialect.MySQL5Dialect");
      lsfb.setHibernateProperties(props);
      lsfb.afterPropertiesSet();
      SessionFactory object = lsfb.getObject();
      return object;
    } catch (IOException e) {
      return null;
    }
  }

  @Bean
  public BeanPostProcessor persistenceTranslation(){ 
      //作用于@Repository标签，将数据层抛出的异常统一转换为 DataAccessException
    return new PersistenceExceptionTranslationPostProcessor();
  }
}

```

##### domain示例

```java

package com.example.domain;

import javax.persistence.*;
import java.util.Date;

@Entity //(name="cargo")
public class Cargo {

    private Cargo() {
    }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne //多对一的关系，交给ORM框架处理
    @JoinColumn(name = "customer")
    private Customer customer;

    @Column(name="product")
    private String product;

    @Column
    private Integer quantity;

    @Column
    private Date orderDate;

    ...//Constructor 和 getter/setter 略
}

```



#### Hibernate三类查询

![image-20200716233630485](总结.assets/image-20200716233630485.png)

##### HQL

```java
//HQL:hibernate query language，即hibernate提供的面向对象的查询语言
@Test
@Transactional
public void hqlTest1() {
    Query query = sessionFactory.getCurrentSession().createQuery("FROM Customer");
    //"FROM Customer"里的Customer是指领域对象，而不是表名
    List<Customer> list = query.list();
    System.out.println(list);
}

@Test
@Transactional
public void hqlTest2() {
    Query query = sessionFactory.getCurrentSession().createQuery("FROM Customer where id = ?");
    query.setParameter(0, 2L);
    List<Customer> list = query.list();
    System.out.println(list);
}
```

##### QBC

```java
//QBC查询: query by criteria 完全面向对象的查询
@Test
@Transactional
public void qbcTest() {
    Criteria criteria = sessionFactory.getCurrentSession().createCriteria(Customer.class);
    criteria.add(Restrictions.eq("id", 2L));
    List<Customer> list = criteria.list();
    System.out.println(list);
}
```

##### SQL

```java
//本地SQL查询
@Test
@Transactional
public void sqlTest() {
    SQLQuery sqlQuery = sessionFactory.getCurrentSession().createSQLQuery("SELECT * FROM customer").addEntity(Customer.class);
    //这里的 customer 指表名
    List<Customer> list = sqlQuery.list();
    System.out.println(list);
}
```



#### @Repository的作用

![image-20200716233637805](总结.assets/image-20200716233637805.png)



### JPA

#### 什么是JPA

![image-20200716233646116](总结.assets/image-20200716233646116.png)

#### JPA配置

![image-20200716233652395](总结.assets/image-20200716233652395.png)

#### EntityManager不是线程安全的

![image-20200716233658062](总结.assets/image-20200716233658062.png)

#### Spring Data JPA

![image-20200716233705237](总结.assets/image-20200716233705237.png)

#### 编写自定义的查询方法

![image-20200716233712546](总结.assets/image-20200716233712546.png)



## 第8节 NoSQL数据库的使用和编程（MongoDB、Redis）



## 第9节 缓存编程



## 第10节 容器、Docker使用



## 第11节 微服务概念、SpringBoot开发微服务



## 第12节 配置服务



## 第13节 服务发现



## 第14节 熔断和容错



## 第15节 服务路由



## 第16节 Kubernates、服务编排、服务部署、Service Mesh